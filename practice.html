<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    body {
      margin: 0;
      text-align: center;
      overflow: hidden;
      background-color: darkgrey;
    }
    canvas {
      background-color: lightgrey;
    }
  </style>
</head>
<body>
  <canvas></canvas>
  <script>
    /*
    // Select the canvas element and get the 2D rendering context
    const canvas = document.querySelector('canvas');
    const ctx = canvas.getContext('2d');

    // Movement flags to track user input
    let forward = false;
    let reverse = false;
    let left = false;
    let right = false;

    // Set canvas dimensions to fill the entire screen
    canvas.height = window.innerHeight;
    canvas.width = 200;

    // Translate the coordinate system to center the canvas horizontally and vertically
    ctx.translate(canvas.width / 2, canvas.height / 2);

    // Function to draw a rectangle at the specified position
    function draw(x, y, width, height) {
      ctx.beginPath();
      ctx.fillStyle = "black"; // Set the rectangle's color
      ctx.rect(x, y, width, height); // Define the rectangle's position and size
      ctx.fill(); // Render the rectangle
    }

    // Listen for key presses and set movement flags accordingly
    document.addEventListener('keydown', (event) => {
      switch (event.key) {
        case 'ArrowUp': // Move forward
          forward = true;
          break;
        case 'ArrowDown': // Move backward
          reverse = true;
          break;
        case 'ArrowLeft': // Move left
          left = true;
          break;
        case 'ArrowRight': // Move right
          right = true;
          break;
      }
    });

    // Listen for key releases and reset movement flags
    document.addEventListener('keyup', (event) => {
      switch (event.key) {
        case 'ArrowUp':
          forward = false;
          break;
        case 'ArrowDown':
          reverse = false;
          break;
        case 'ArrowLeft':
          left = false;
          break;
        case 'ArrowRight':
          right = false;
          break;
      }
    });

    // Movement-related variables
    const acceleration = 0.2; // Acceleration rate
    const friction = 0.05; // Friction to reduce speed when not moving
    const maxSpeed = 4; // Maximum forward speed
    let speed = 0; // Initial speed
    let x = 0; // Initial horizontal position
    let y = 0; // Initial vertical position

    // Function to handle movement logic
    function move() {
      // Increase speed when moving forward, up to maxSpeed
      if (forward) {
        speed = Math.min(speed + acceleration, maxSpeed);
      }
      // Decrease speed when reversing, with a maximum reverse speed
      if (reverse) {
        speed = Math.max(speed - acceleration, -maxSpeed / 2);
      }

      // Apply friction to gradually stop movement when no key is pressed
      if (!forward && !reverse) {
        if (speed > 0) {
          speed = Math.max(speed - friction, 0); // Gradually reduce positive speed
        } else if (speed < 0) {
          speed = Math.min(speed + friction, 0); // Gradually reduce negative speed
        }
      }

      // Move horizontally when left or right keys are pressed
      if (left) {
        x -= 2; // Move left
      }
      if (right) {
        x += 2; // Move right
      }

      // Update vertical position based on speed
      y -= speed;
    }

    // Main animation loop
    function animate() {
      // Clear the canvas before each frame
      ctx.clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);
      move(); // Update position based on input
      draw(x, y, 30, 50); // Draw the rectangle at the updated position
      requestAnimationFrame(animate); // Recursively call animate for the next frame
    }

    // Start the animation loop
    animate();

    */

    // Select the canvas element and get the 2D rendering context
const canvas = document.querySelector('canvas');
const ctx = canvas.getContext('2d');

// Set canvas dimensions to fill the entire screen
canvas.height = window.innerHeight;
canvas.width = 200;

// Translate the coordinate system to center the canvas horizontally and vertically
ctx.translate(canvas.width / 2, canvas.height / 2);

// Create a class to encapsulate the rectangle and movement logic
class Rectangle {
  constructor(x, y, width, height) {
    this.x = x; // Initial horizontal position
    this.y = y; // Initial vertical position
    this.width = width; // Rectangle width
    this.height = height; // Rectangle height

    // Movement flags
    this.forward = false;
    this.reverse = false;
    this.left = false;
    this.right = false;

    // Movement-related variables
    this.acceleration = 0.2; // Acceleration rate
    this.friction = 0.05; // Friction to reduce speed
    this.maxSpeed = 4; // Maximum forward speed
    this.speed = 0; // Initial speed

    // Add event listeners for keyboard input
    this.addEventListeners();
  }

  // Method to draw the rectangle on the canvas
  draw(ctx) {
    ctx.beginPath();
    ctx.fillStyle = "black"; // Set the rectangle's color
    ctx.rect(this.x, this.y, this.width, this.height); // Define rectangle position and size
    ctx.fill(); // Render the rectangle
  }

  // Method to handle movement logic
  move() {
    // Increase speed when moving forward, up to maxSpeed
    if (this.forward) {
      this.speed = Math.min(this.speed + this.acceleration, this.maxSpeed);
    }
    // Decrease speed when reversing, with a maximum reverse speed
    if (this.reverse) {
      this.speed = Math.max(this.speed - this.acceleration, -this.maxSpeed / 2);
    }

    // Apply friction to gradually stop movement when no key is pressed
    if (!this.forward && !this.reverse) {
      if (this.speed > 0) {
        this.speed = Math.max(this.speed - this.friction, 0); // Gradually reduce positive speed
      } else if (this.speed < 0) {
        this.speed = Math.min(this.speed + this.friction, 0); // Gradually reduce negative speed
      }
    }

    // Move horizontally when left or right keys are pressed
    if (this.left) {
      this.x -= 2; // Move left
    }
    if (this.right) {
      this.x += 2; // Move right
    }

    // Update vertical position based on speed
    this.y -= this.speed;
  }

  // Method to add keyboard event listeners
  addEventListeners() {
    document.addEventListener('keydown', (event) => {
      switch (event.key) {
        case 'ArrowUp':
          this.forward = true;
          break;
        case 'ArrowDown':
          this.reverse = true;
          break;
        case 'ArrowLeft':
          this.left = true;
          break;
        case 'ArrowRight':
          this.right = true;
          break;
      }
    });

    document.addEventListener('keyup', (event) => {
      switch (event.key) {
        case 'ArrowUp':
          this.forward = false;
          break;
        case 'ArrowDown':
          this.reverse = false;
          break;
        case 'ArrowLeft':
          this.left = false;
          break;
        case 'ArrowRight':
          this.right = false;
          break;
      }
    });
  }
}

// Instantiate the Rectangle class
const rectangle = new Rectangle(0, 0, 30, 50);

// Main animation loop
function animate() {
  // Clear the canvas before each frame
  ctx.clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);

  // Update position based on input
  rectangle.move();

  // Draw the rectangle at the updated position
  rectangle.draw(ctx);

  // Recursively call animate for the next frame
  requestAnimationFrame(animate);
}

// Start the animation loop
animate();




  </script>
</body>
</html>
